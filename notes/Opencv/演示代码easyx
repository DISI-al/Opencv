#include <graphics.h>   // EasyX 图形库
#include <iostream>
#include <vector>
#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <string>
#include <cmath>

using namespace std;

// 窗口与矩阵参数
const int MATRIX_SIZE = 5;
const int KERNEL_SIZE = 3;
const int CELL  = 50;
const int PAD   = 50;
const int OUT_X = 400;
const int WIN_W = 900;
const int WIN_H = 450;

// 输入矩阵
const int input[5][5] = {
    {1, 2, 0, 1, 2},
    {2, 1, 0, 2, 1},
    {0, 1, 2, 1, 0},
    {2, 0, 1, 2, 1},
    {1, 2, 1, 0, 1}
};

// 卷积核结构体
struct KernelDef {
    string name;
    string type;
    string func;
    int k[3][3];
};

// 8 种卷积核配置
vector<KernelDef> kernels = {
    {"Laplacian",    "边缘检测", "无方向边缘提取，增强图像轮廓", {{0, 1, 0}, {1, -4, 1}, {0, 1, 0}}},
    {"Sobel X",      "边缘检测", "检测水平方向边缘（垂直梯度）", {{-1, 0, 1}, {-2, 0, 2}, {-1, 0, 1}}},
    {"Sobel Y",      "边缘检测", "检测垂直方向边缘（水平梯度）", {{-1, -2, -1}, {0, 0, 0}, {1, 2, 1}}},
    {"Prewitt X",    "边缘检测", "水平边缘检测，对噪声更鲁棒",   {{-1, 0, 1}, {-1, 0, 1}, {-1, 0, 1}}},
    {"Prewitt Y",    "边缘检测", "垂直边缘检测，计算量更小",     {{-1, -1, -1}, {0, 0, 0}, {1, 1, 1}}},
    {"Gaussian Blur","图像平滑", "高斯加权模糊，保留图像细节",     {{1, 2, 1}, {2, 4, 2}, {1, 2, 1}}},
    {"Box Blur",     "图像平滑", "均值模糊，快速降低图像噪声",     {{1, 1, 1}, {1, 1, 1}, {1, 1, 1}}},
    {"Sharpen",      "图像增强", "增强图像细节，提升画面清晰度",   {{0, -1, 0}, {-1, 5, -1}, {0, -1, 0}}}
};

// 绘制矩阵函数
void drawMatrix(const vector<vector<int>>& mat, int sx, int sy, COLORREF line = BLACK) {
    setlinecolor(line);
    settextcolor(line);
    for (int i = 0; i < (int)mat.size(); i++) {
        for (int j = 0; j < (int)mat[0].size(); j++) {
            rectangle(sx + j * CELL, sy + i * CELL,
                      sx + (j + 1) * CELL, sy + (i + 1) * CELL);
            char buf[16]; sprintf_s(buf, "%d", mat[i][j]);
            outtextxy(sx + j * CELL + 15, sy + i * CELL + 15, buf);
        }
    }
}

// 单步卷积计算 + 可视化（核心修改：红色文字上移一格）
int convStepAndShow(int row, int col, const int in[][5], const int ker[][3], double norm = 1.0) {
    int offset = KERNEL_SIZE / 2;
    int sum = 0;

    // 绿色框坐标（保持不变）
    int x0 = PAD + col * CELL - offset * CELL;
    int y0 = PAD + row * CELL - offset * CELL;
    int x1 = x0 + KERNEL_SIZE * CELL;
    int y1 = y0 + KERNEL_SIZE * CELL;

    setlinecolor(GREEN);
    setlinestyle(PS_SOLID, 3);
    rectangle(x0, y0, x1, y1);
    setlinestyle(PS_SOLID, 1);

    // 卷积求和逻辑
    for (int m = 0; m < KERNEL_SIZE; m++) {
        for (int n = 0; n < KERNEL_SIZE; n++) {
            int curr_row = row + m - offset;
            int curr_col = col + n - offset;
            int val = 0;
            if (curr_row >= 0 && curr_row < MATRIX_SIZE && curr_col >= 0 && curr_col < MATRIX_SIZE) {
                val = in[curr_row][curr_col];
            }
            int prod = val * ker[m][n];
            sum += prod;
            // 核心修改：纵坐标减去 CELL，红色文字整体上移一格
            char buf[32];
            sprintf_s(buf, "%d*%d=%d", val, ker[m][n], prod);
            settextcolor(RGB(200, 0, 0));
            outtextxy(PAD + curr_col * CELL + 2, PAD + curr_row * CELL + 55 - CELL, buf);
        }
    }

    return (int)round((double)sum / norm);
}

// 卷积核提示页（停留5秒）
void showKernelTip(const KernelDef& kd) {
    setfillcolor(WHITE);
    solidrectangle(0, 0, WIN_W, WIN_H);
    setbkmode(TRANSPARENT);
    settextcolor(RGB(0, 50, 150));

    settextstyle(32, 0, "微软雅黑", 0, 0, FW_BOLD, false, false, false);
    outtextxy(50, 80, ("卷积核名称：" + kd.name).c_str());

    settextstyle(28, 0, "微软雅黑", 0, 0, FW_BOLD, false, false, false);
    outtextxy(50, 150, ("类型：" + kd.type).c_str());

    settextstyle(24, 0, "微软雅黑", 0, 0, FW_BOLD, false, false, false);
    outtextxy(50, 220, ("作用：" + kd.func).c_str());

    settextcolor(RGB(100, 100, 100));
    settextstyle(20, 0, "微软雅黑", 0, 0, FW_NORMAL, false, false, false);
    outtextxy(50, 350, "5秒后自动开始演示...");

    FlushBatchDraw();
    Sleep(5000);
}

int main() {
    initgraph(WIN_W, WIN_H);
    setbkcolor(WHITE);
    cleardevice();
    setbkmode(TRANSPARENT);
    BeginBatchDraw();

    // 输入矩阵转为 vector
    vector<vector<int>> inputVec(MATRIX_SIZE, vector<int>(MATRIX_SIZE));
    for (int i = 0; i < MATRIX_SIZE; i++)
        for (int j = 0; j < MATRIX_SIZE; j++)
            inputVec[i][j] = input[i][j];

    // 遍历所有卷积核演示
    for (auto& kd : kernels) {
        showKernelTip(kd);

        vector<vector<int>> outVec(MATRIX_SIZE, vector<int>(MATRIX_SIZE, 0));
        string outTitle = "Output (" + kd.name + ")";

        // 初始画面
        setfillcolor(WHITE);
        solidrectangle(0, 0, WIN_W, WIN_H);
        drawMatrix(inputVec, PAD, PAD, BLACK);
        drawMatrix(outVec, OUT_X, PAD, RGB(120, 120, 120));
        settextcolor(BLACK);
        settextstyle(20, 0, "微软雅黑", 0, 0, FW_NORMAL, false, false, false);
        outtextxy(PAD, 20, "Input");
        outtextxy(OUT_X, 20, outTitle.c_str());
        FlushBatchDraw();
        Sleep(500);

        // 归一化系数
        double norm = 1.0;
        if (kd.name == "Gaussian Blur") norm = 16.0;
        if (kd.name == "Box Blur") norm = 9.0;

        // 逐像素卷积：row是行，col是列，与输出矩阵的红色框一一对应
        for (int row = 0; row < MATRIX_SIZE; row++) {
            for (int col = 0; col < MATRIX_SIZE; col++) {
                setfillcolor(WHITE);
                solidrectangle(0, 0, WIN_W, WIN_H);
                drawMatrix(inputVec, PAD, PAD, BLACK);
                drawMatrix(outVec, OUT_X, PAD, RGB(120, 120, 120));
                settextcolor(BLACK);
                settextstyle(20, 0, "微软雅黑", 0, 0, FW_NORMAL, false, false, false);
                outtextxy(PAD, 20, "Input");
                outtextxy(OUT_X, 20, outTitle.c_str());

                // 计算当前行列的卷积值
                int sum = convStepAndShow(row, col, input, kd.k, norm);
                outVec[row][col] = sum;

                // 红色框标注输出矩阵的当前计算位置
                setlinecolor(RED);
                setlinestyle(PS_SOLID, 3);
                rectangle(OUT_X + col * CELL, PAD + row * CELL,
                          OUT_X + (col + 1) * CELL, PAD + (row + 1) * CELL);
                setlinestyle(PS_SOLID, 1);
                settextcolor(RED);
                char buf[16]; sprintf_s(buf, "%d", sum);
                outtextxy(OUT_X + col * CELL + 15, PAD + row * CELL + 15, buf);

                FlushBatchDraw();
                Sleep(1200); // 控制动画速度
            }
        }

        // 完成提示
        settextcolor(BLUE);
        settextstyle(18, 0, "微软雅黑", 0, 0, FW_NORMAL, false, false, false);
        string doneTip = "Done: " + kd.name + ". Press any key or wait 1s to continue.";
        outtextxy(50, 360, doneTip.c_str());
        FlushBatchDraw();

        for (int t = 0; t < 10; ++t) {
            if (_kbhit()) { _getch(); break; }
            Sleep(100);
        }
    }

    settextcolor(BLUE);
    settextstyle(18, 0, "微软雅黑", 0, 0, FW_NORMAL, false, false, false);
    outtextxy(50, 380, "All kernels done. Press any key to exit.");
    FlushBatchDraw();

    _getch();
    EndBatchDraw();
    closegraph();
    return 0;
}